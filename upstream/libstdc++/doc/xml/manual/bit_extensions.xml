<chapter
		xmlns="http://docbook.org/ns/docbook"
		xmlns:xlink="http://www.w3.org/1999/xlink"
		xmlns:xi="http://www.w3.org/2001/XInclude"
		version="5.0"
		xml:id="ext.bit"
		xreflabel="Bit Extensions">
	<?dbhtml filename="bit_extensions.html" ?>

	<info>
		<title>
			Bit Extensions - Fundamental Bit Utilities, Ranges and Container Extensions ("itsy.bitsy")
		</title>
		<keywordset>
			<keyword>ISO C++</keyword>
			<keyword>library</keyword>
			<keyword>extension</keyword>
			<keyword>bit</keyword>
			<keyword>bit_value</keyword>
			<keyword>bit_reference</keyword>
			<keyword>bit_iterator</keyword>
			<keyword>bit_range</keyword>
			<keyword>dynamic_bitset</keyword>
			<keyword>bit_sequence</keyword>
			<keyword>sequence</keyword>
			<keyword>range</keyword>
			<keyword>container</keyword>
			<keyword>algorithm</keyword>
		</keywordset>
	</info>

	<para>
		A collection of utilities, algorithmic improvements, view adaptors and container adaptors for working with 1-bit objects represented by
		<literal>0</literal>
		(
		<literal>false</literal>
		) or
		<literal>1</literal>
		(
		<literal>true</literal>
		). Affectionately, this library is referred to as "itsy.bitsy".
	</para>

	<para>
		All of these iterators and structures can be accessed VIA including the following extension header in your code:
		<code>
			<![CDATA[#include <ext/bit>]]>
		</code>
		.
		As stated previously, nothing about this design, its Application Programming Interface (API) or its Application Binary Interface (ABI) are at all stable or to be depended upon. Performance metrics for various algorithms and internal optimizations are still being contributed to make this the best library version possible. It will be more stable if and when these various structures and proposed for inclusion in -- hopefully -- C++23 or C++26.
	</para>

	<section
			xml:id="ext.bit.design"
			xreflabel="Design">
		<info>
			<title>Design</title>
		</info>
		<para>
			The bit extensions abstract the smallest unit of information in C++ -- a bit -- in easy-to-use, easy-to-optimize, and highly flexible iterators and structures. This comes as proposals for bit manipulation have stacked up in the Standard C++ mailing archives but need both exploration and implementation to further them. In particular, these extensions focus on candidates likely for future standardization, including
			<link xlink:href="https://wg21.link/n2050">N2050 - Proposal to Add a Dynamically Sizeable Bitset to the Standard Library Technical Report</link>
			and the newer
			<link xlink:href="https://wg21.link/p0237r10">P0237 - fundamental bit manipulation utilities</link>
			.
		</para>
		<para>
			The implementations provided here are not verbatim with either N2050's or P0237's work. While closely followed, a number of different design decisions were taken with the advent of
			<link xlink:href="http://eel.is/c++draft/ranges">C++20's new Range machinery</link>
			. Other operations were either added or removed to promote better safety in the type (e.g., removing arithmetic operations from
			<code>
				<![CDATA[bit_pointer<Iterator>]]>
			</code>
			to prevent crashes and overflow when the reference type does not have a contiguous store) or added for ease of use and clarity of API (e.g.,
			<code>C++</code>
			). Most notably,
			<code>bit_sequence</code>
			(a more flexible
			<code>dynamic_bitset</code>
			)
			is implemented as a container adaptor rather than a concrete type or a type which only takes a single
			<code>value_type</code>
			template parameter.
		</para>
		<para>
				There are small, mostly private implementations of the functionality provided by these extensions already in libstdc++ in various forms: these abstractions will hopefully pave the way for them to not only be in the standard but also exhibit dependable performance characteristics without requiring more hand-crafted optimization to be applied to individual use cases and specific types.
		</para>
		<para>
			All abstractions treat values as a sequence of bits, with 0 being the least significant bit and N-1 being the most significant bit. The most significant bit, N-1, is determined by the binary digits N in the value's object representation. This is picked out of a template class,
			<code>
				<![CDATA[binary_digits_v<Type>]]>
			</code>
			. This generally computes
			<code>
				<![CDATA[sizeof(Type) * CHAR_BIT]]>
			</code>
			as the number of bits. For signed types, it computes the previous value but with a
			<code>- 1</code>
			to exclude observing the sign bit (this is reliable because C++20 has formalized a twos-complement integer model).
		</para>
		<section
				xml:id="ext.bit.design.layers"
				xreflabel="Layers">
			<title>Abstraction Layers</title>
			<para>There are 4 layers of functionality. Each layer provides increasingly more functionality, and depends on the last.</para>
			<section
					xml:id="ext.bit.design.layers.utilities"
					xreflabel="bit_utilities">
				<title>Abstraction Layer 0: bit_utilities</title>
				<para>
					A collection of fundamental utilites for properly and correctly working with the bits of integral and enumeration types. Includes
					<code>
						<![CDATA[binary_digits<IntegralOrEnumerationType>]]>
					</code>
					helper type,
					<code>
						<![CDATA[bit_value]]>
					</code>
					type as a "strong typedef" for a single bit,
					<code>
						<![CDATA[bit_reference<ReferenceType, MaskType>]]>
					</code>
					which wraps a Reference and presents a single bit interface to it,
					<code>
						<![CDATA[bit_iterator<Iterator>]]>
					</code>
					for enumering the individual bits of the
					<code>Iterator</code>
					's
					<code>value_type</code>
					, and
					<code>
						<![CDATA[bit_pointer<Iterator>]]>
					</code>
					as the pointer analogue of a single bit reference. All indices and bit positions are communicated with the least significant bit starting at 0 before progressing upwards towards the most significant bit at 1.
				</para>
			</section>

			<section
					xml:id="ext.bit.design.layers.algorithms"
					xreflabel="bit_algorithms">
				<title>Abstraction Layer 1: bit algorithims</title>
				<para>
					A collection of function template overloads which employ the bit utilities defined from before to provide optimized implementations of certain standard algorithms, including
					<literal>std::find</literal>
					,
					<literal>std::equal</literal>
					,
					<literal>std::copy(_n)</literal>
					, and more. See the performance section below for more details on the various improvements made to various algorithms.
				</para>
			</section>
			<section
					xml:id="ext.bit.design.layers.bit_view"
					xreflabel="bit_view">
				<title>
					Abstraction Layer 2:
					<code>
						<![CDATA[bit_view<Range, Bounds>]]>
					</code>
				</title>
				<para>
					A range adaptor which takes a range and provides an easy interface to iterate over its bits in very specific sections through use of its
					<code>
						Bounds
					</code>
					. Includes a
					<code>
						<![CDATA[bit_view<Range, Bounds>]]>
					</code>
					type for viewing the
					<code>[begin(), end())</code>
					values of a range as a sequence of bits,
					<code>
						<![CDATA[word_bounds<Range>]]>
					</code>
					bounds type,
					<code>
						<![CDATA[dynamic_bounds]]>
					</code>
					bounds type for bounds determined at run time, and
					<code>
						<![CDATA[static_bounds<BeginBit, EndBit>]]>
					</code>
					bounds type for bounds determined at compile-time. It can be used on single values or multiple values. An example:
					<programlisting>
						<![CDATA[
					#include <ext/bit>
					#include <string_view>
					#include <iostream>
					
					int main (int argc, char*[] argv) 
					{
						for (int i = 0; i < argc; ++i) 
							{
								const char* arg = argv[i];
								__gnu_cxx::bit_view<std::string_view> arg_bits(arg);
								std::cout << ""the first ASCII letter of the arg is ";
								if (bits[6]) {
									std::cout << "uppercase" << std::endl;
								}
								else {
									std::cout << "lowercase" << std::endl;
								}
							}

						return 0;
					}
					]]>
					</programlisting>
				</para>
				<para>
					Note that
					<code>
						<![CDATA[bit_view<Range, Bounds>]]>
					</code>
					also includes
					<code>begin()</code>
					and
					<code>end()</code>
					methods, as well as a suite of methods for checking bits (
					<code>.test()</code>
					) and more:
					<programlisting>
						<![CDATA[
					#include <ext/bit>
					#include <span>
					#include <cstddef>
					#include <algorithm>

					int main (int argc, char*[] argv) 
					{
						std::uint64_t value{ std::numeric_limits<std::uint64_t>::max() };
						__gnu_cxx::bit_view<std::span<std::uint64_t>> value_bits(&value, &value + 1);
						// returns 0
						return std::count(value_bits.cbegin(), value_bits.cend(), false);
					}
					]]>
					</programlisting>
				</para>
			</section>

			<section
					xml:id="ext.bit.design.layers.bit_sequence"
					xreflabel="bit_sequence">
				<title>
					Abstraction Layer 3:
					<code>
						<![CDATA[bit_sequence<Container>]]>
					</code>
				</title>
				<para>
					A container adaptor which takes a container and adapts its
					<code>value_type</code>
					to be a sequence of bits. It maintains the per-bit position as an invariant of the class. It can be constructed from its underlying container, but also maintains an easy-to-use interface that is identical to other Sequence Containers in the standard.
				</para>
			</section>
		</section>
	</section>
	<section
			xml:id="ext.bit.using"
			xreflabel="Using">
		<title>Using the Library</title>
		<para>
			Each higher layer of this library builds on top of the lower layers. We will start at the top -- with wrapping, owning containers -- and progress steadily downward. The library is also a header-only, linker-hassle free library.
		</para>
		<section
				xml:id="ext.bit.using.bit_sequence"
				xreflabel="Bit.Sequence">
			<title>Bit Sequence</title>
			<para>
				<code>
					<![CDATA[__gnu_cxx::bit_sequence<Container>]]>
				</code>
				is an owning sequence container adaptor. It can be used like so:
				<programlisting>
					<![CDATA[
#include <ext/bit>

#include <cassert>

int main () {
	// construct with initializer list
	__gnu_cxx::bit_sequence<std::vector<std::size_t>> bits{
		false, true, true, false, false
	};
	// construct from iterators just like other containers
	__gnu_cxx::bit_sequence<std::vector<std::size_t>> other_bits(
		bits.cbegin(), bits.cend();
	);

	// can compare
	assert(bits == other_bits);
	assert(!(bits != other_bits));

	// insertion
	bits.push_back(false);
	bits.insert(bits.begin() + 2, {true, true});
	assert(bits.size() == 8);
	assert(bits.count(true) == 4);

	// erasure
	bits.erase(bits.begin() + 1, bits.begin() + 3);
	assert(bits.size() == 6);
	assert(bits.popcount() == 2);

	// comparison works exactly the same
	assert(bits != other_bits);
	assert(!(bits == other_bits));

	return 0;
}
]]>
				</programlisting>
			</para>

			<para>
				There is a convenience alias --
				<code>
					<![CDATA[__gnu_cxx::dynamic_bitset<T, Allocator>]]>
				</code>
				, which defaults to some
				<code>
					<![CDATA[std::vector<T, Allocator>]]>
				</code>
				-alike storage. See the below section on [future work](#small-buffer) for additional containers for the hope of what the default choice of container for this convenience alias should use:
				<programlisting>
					<![CDATA[
#include <ext/bit>

int main () {
	__gnu_cxx::dynamic_bitset<std::size_t> bits{false, true, true, false, false};

	/* bit work here! */

	return 0;
}
]]>
				</programlisting>
			</para>
			<para>
				Additionally, one can move storage directly into the bit sequence by using the
				<code>
					<![CDATA[std::in_place]]>
				</code>
				constructors:
				<programlisting>
					<![CDATA[
#include <ext/bit>

#include <cstdint>
#include <cassert>

int main () {
	std::vector<std::uint32_t> words{ 0xff00ff00, 0xff00ff00 };
	__gnu_cxx::bit_sequence<std::vector<std::uint32_t>> bits(std::in_place, std::move(words));

	const std::size_t bits_size = bits.size();
	
	// size of the container is 2 words
	assert(bits_size == __gnu_cxx::binary_digits_v<std::uint32_t> * 2);
	assert(bits_size == 64);

	// assert 16-bit pattern
	for (std::size_t index = 0; index < bits_size; ++index) {
		if ((index % 16) < 8) {
			assert(!bits[index]);
		}
		else {
			assert(bits[index]);
		}
	}

	return 0;
}
]]>
				</programlisting>
			</para>
		</section>
		<section
				xml:id="ext.bit.using.bit_view"
				xreflabel="Bit.View">
			<title>Bit View</title>

			<para>
				The types at this layer sit below
				<code>
					<![CDATA[bit_sequence]]>
				</code>
				in terms of abstraction power.
				<code>
					<![CDATA[bit_view<Range, Bounds>]]>
				</code>
				is the type which views a set of bits and provides a potentially mutable view of those bits. It cannot
				<code>insert</code>
				<code>erase</code>
				into the underlying range, but supports in-place modifications and mutability. For example, if the
				<code>
					<![CDATA[Range]]>
				</code>
				is a
				<code>
					<![CDATA[std::span<T>]]>
				</code>
				, then the type is mutable:
				<programlisting>
					<![CDATA[
#include <ext/bit>

#include <string>
#include <span>
#include <cassert>

int main () {
	std::string str = "Howdy!";
	std::cout << str << std::endl;
	// arguments get forwarded directly
	// to underlying range constructor
	__gnu_cxx::bit_view<std::span<char>> str_bits(str);

	// iterators
	auto bits_it = str_bits.begin();
	assert(bits_it.position() == 0);
	assert(*bits_it == __gnu_cxx::bit0);
	++bits_it;
	assert(bits_it.position() == 1);
	assert(*bits_it == __gnu_cxx::bit0);
	bits_it += 4;
	assert(bits_it.position() == 5);
	assert(*bits_it == __gnu_cxx::bit0);
	// flip a single bit
	// pointed to by bits_it
	bits_it->flip();
	assert(*bits_it == __gnu_cxx::bit1);

	// we flipped the ASCII bit
	// for a capital letter!
	std::cout << str << std::endl;
	assert(str == "howdy!");

	return 0;
}
]]>
				</programlisting>
			</para>
			<para>
				But if the
				<code>
					<![CDATA[Range]]>
				</code>
				is something like a
				<code>
					<![CDATA[std::string_view]]>
				</code>
				or a
				<code>
					<![CDATA[std::span<const T>]]>
				</code>
				, whose iterators and interface is immutable,
				<code>
					<![CDATA[bit_view]]>
				</code>
				becomes immutable as well:
				<programlisting>
					<![CDATA[
#include <ext/bit>

#include <cassert>

#include <span>
#include <cstdint>

int main() {
	std::vector<std::uint16_t> storage{ 0, 0, 0 };
	__gnu_cxx::bit_view<std::span<const std::uint16_t>> bits(storage);

	assert(bits.size() == 48);

	// the below will trigger a compiler error,
	// thus preserving const-safety
	(*bits.begin()) = true;
	bits[16] = __gnu_cxx::bit1;
	bits.begin()->flip();

	// can use auto, just showing the actual type
	for (__gnu_cxx::bit_reference<const std::uint16_t&> bit_ref : bits) {
		bit_value value = bit_ref;
		assert(value.value()); // returns the bool value
		// cannot use mutable methods: 
		// compiler will error below!
		bit_ref.flip();
		bit_ref.set();
		bit_ref.reset();
	}

	return 0;
}
]]>
				</programlisting>
			</para>
			<para>
				For
				<code>
					<![CDATA[bit_view<Range, Bounds>]]>
				</code>
				, the optional second
				<code>
					<![CDATA[Bounds]]>
				</code>
				template parameter can be used to specify very specific extents:
				<programlisting>
					<![CDATA[
#include <ext/bit>

#include <string_view>
#include <cassert>

int main () {
	std::array<std::uint32_t, 2> storage{
		// 0xFBFF;
		// (MSB) 0b‭1111101111111111‬ (LSB)
		0x0000FBFF, 
		0xFFFFFFFF 
	};
	using range_t = std::basic_string_view<std::uint32_t>;
	using bounds_t = __gnu_cxx::bit_bounds<10, 22>;
	__gnu_cxx::bit_view<range_t, bounds_t> view_specific_bits(
		storage.data(), storage.size()
	);

	assert(view_specific_bits.size() == 12);
	// 0th bit of biew is 10th bit,
	// 10th bit of 0xFBFF is false
	assert(view_specific_bits[0] == __gnu_cxx::bit0);

	return 0;
}
]]>
				</programlisting>
			</para>
			<para>
				And, as previously stated, it can be used at compile-time and in constant-evaluated contexts:
				<programlisting>
					<![CDATA[
#include <ext/bit>

#include <string_view>
#include <cassert>

int main () {
	static constexpr unsigned data[] = { 0b0001, 0b0010 };
	static constexpr __gnu_cxx::bit_view<std::basic_string_view<unsigned>> data_bits(&data[0], 2);

	static_assert(data_bits[0], "First bit is not true (expected: true)!");
	static_assert(!data_bits.test(1), "Second bit is true  (expected: false)!");
	static_assert(*(data_bits.begin() + __gnu_cxx::binary_digits_v<unsigned> + 1),
	  "Second bit in second word is not true (expected: true)!");
	static_assert(data_bits.size() == (sizeof(unsigned) * CHAR_BIT * 2),
	  "The size of the bit view is not 2 x unsigned");
	static_assert(data_bits.size() == (__gnu_cxx::binary_digits_v<unsigned> * 2),
	  "The size of the bit view is not 2 x unsigned");
	static_assert(!data_bits[3].value(), "The bit is true (expected: false)!");

	return 0;
}
]]>
				</programlisting>
			</para>
			<para>
				All methods found on a
				<code>
					<![CDATA[bit_view]]>
				</code>
				also exist on all variants of
				<code>
					<![CDATA[bit_sequence]]>
				</code>
				.
			</para>
		</section>
		<section
				xml:id="ext.bit.using.bit_iterator"
				xreflabel="Bit.Iterator">
			<title>Bit Iterator</title>
			<para>
				<code>
					<![CDATA[__gnu_cxx::bit_iterator<Iterator>]]>
				</code>
				is a class template. It is considered the "low level" portion of this library. It takes an iterator to increment when it iterates from
				<code>
					<![CDATA[[0, __gnu_cxx::binary_digits_v<underlying_value_type>)]]>
				</code>
				. Generally, what that means is that a
				<code>
					<![CDATA[std::uint32_t]]>
				</code>
				will iterate from 0 to 31 inclusive, an
				<code>
					<![CDATA[unsigned long long]]>
				</code>
				(depending on platform specifics) might go from 0 to 63 inclusive, and so on and so forth. This can be inspected with the
				<code>
					<![CDATA[.position()]]>
				</code>
				and
				<code>
					<![CDATA[.mask()]]>
				</code>
				properties:
				<programlisting>
					<![CDATA[
#include <ext/bit>

#include <random>
#include <limits>
#include <algorithm>
#include <iostream>

int main() {
	using sequence = std::list<int>;
	sequence seq{ 100, 0 };
	std::random_device rd{};
	std::default_random_engine rand_engine(rd());
	std::uniform_int_distribution<int> rand_distribution(
		std::numeric_limits<int>::max() - 32, std::numeric_limits<int>::max());
	std::generate_n(seq.begin(), seq.size(), [&]() { return rand_distribution(rand_engine); });

	__gnu_cxx::bit_iterator<typename sequence::const_iterator> first(seq.cbegin(), 0);
	__gnu_cxx::bit_iterator<typename sequence::const_iterator> last(seq.cend(), 0);

	if (auto it = std::find(first, last, __gnu_cxx::bit0); it != last) {
		__gnu_cxx::bit_reference<typename sequence::const_reference> ref = *it;
		std::cout << "Found a 0 bit at the " << std::distance(it, last) << " element in the "
							<< seq.size() << ", at bit position" << ref.position() << "( mask: " << ref.mask()
							<< " | applied to value: " << *it.base() << ")" << std::endl;
	}

	return 0;
}
				]]>
				</programlisting>
			</para>
			<para>
				It's
				<code>
					<![CDATA[value_type]]>
				</code>
				is a
				<code>
					<![CDATA[bit_value]]>
				</code>
				, and its reference type is a
				<code>
					<![CDATA[bit_reference<WordType, MaskType>]]>
				</code>
				.
				<code>
					<![CDATA[bit_reference]]>
				</code>
				keeps on the reference and the position/mask value.
				<code>
					<![CDATA[bit_value]]>
				</code>
				discards that is only represents a single bit. As seen from the above example, using the basic
				<code>
					<![CDATA[bit_iterator]]>
				</code>
				API is incredibly verbose: it is highly encouraged to use the top-level ranges API or similar when possible, unless attempting to create your own ranges and containers that iterate over bits.
			</para>
		</section>
	</section>
	<section>
		<title>Performance</title>
		<para>
			The bit iterators here have had select optimizations applied to certain algorithms which can handle it. Most of these include the non-predicate versions of functions present in the C++ algorithms. The reason the versions taking a predicate cannot be optimized is because predicates only have the requirement that they successfully pinpoint an element or partition a range: at no point does the standard require that the comparisons cater to any particular value in the sequence of bits, or respond in a predicable way to what amounts to a 0 bit or a 1 bit. That makes it impossible to optimize, say
			<code>find_if</code>
			, because there is no reasoning that can be applied to the predicate. Calling
			<code>unary_predicate(false)</code>
			one time and
			<code>unary_predicate(false)</code>
			another time can yield 2 different results. It could be based on the time of day, the number of times the predicate is called, some internal state, etc.: no matter what the case is, the predicate-taking versions of these functions cannot be optimized. It can't even be optimized if we detect e.g.
			<code>
				<![CDATA[std::less<T>]]>
			</code>
			because someone can create a specialization of that standard predicate and do crazy things with it. This is an unfortunate but fundamental truth to the predicate-taking algorithms.
		</para>
		<para>
			This does not mean there are no optimization opportunities at all. In the current version of itsy.bitsy, we currently optimize the following:
			<orderedlist>
				<listitem>
					<para>
						<code>std::equal</code>
						, 3-iterator and 4-iterator version
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::find</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::find_first_of</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::lexicographic_compare</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::copy</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::copy_n</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::fill</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::fill_n</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::count</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::is_sorted</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>std::is_sorted_until</code>
					</para>
				</listitem>
			</orderedlist>
		</para>
		<para>
			Here is some of the example performance from a recent build of GCC:
			<programlisting>
				<![CDATA[----------------------------------------------------------------------
Benchmark                            Time             CPU   Iterations
----------------------------------------------------------------------
noop                             0.000 ns        0.000 ns   1000000000
is_sorted_by_hand                 2807 ns         2762 ns       248889
is_sorted_base                   50573 ns        50223 ns        11200
is_sorted_vector_bool           252820 ns       256696 ns         2800
is_sorted_bitset                202140 ns       199507 ns         3446
is_sorted_itsy_bitsy               839 ns          837 ns       746667
is_sorted_until_by_hand           2812 ns         2825 ns       248889
is_sorted_until_base             51320 ns        51562 ns        10000
is_sorted_until_vector_bool     255426 ns       256696 ns         2800
is_sorted_until_bitset          198101 ns       194972 ns         3446
is_sorted_until_itsy_bitsy         712 ns          715 ns       896000
find_by_hand                      2694 ns         2727 ns       263529
find_base                        23847 ns        24065 ns        29867
find_vector_bool                 89738 ns        89979 ns         7467
find_bitset                      96646 ns        96257 ns         7467
find_itsy_bitsy                   2718 ns         2727 ns       263529
fill_by_hand                       272 ns          273 ns      2635294
fill_base                         2796 ns         2787 ns       263529
fill_vector_bool                   271 ns          270 ns      2488889
fill_bitset                     137941 ns       139509 ns         5600
fill_bitset_smart                  257 ns          257 ns      2488889
fill_itsy_bitsy                    263 ns          268 ns      2800000
fill_itsy_bitsy_smart              257 ns          257 ns      2800000
sized_fill_by_hand                 257 ns          255 ns      2635294
sized_fill_base                   2580 ns         2623 ns       280000
sized_fill_vector_bool          127094 ns       128348 ns         5600
sized_fill_bitset               125951 ns       125552 ns         4978
sized_fill_bitset_smart            251 ns          251 ns      2800000
sized_fill_itsy_bitsy              260 ns          262 ns      2800000
sized_fill_itsy_bitsy_smart        267 ns          268 ns      2800000
equal_by_hand                     1030 ns         1046 ns       746667
equal_memcmp                     0.328 ns        0.312 ns   1000000000
equal_base                       0.318 ns        0.312 ns   1000000000
equal_vector_bool               242570 ns       239955 ns         2800
equal_vector_bool_operator      270586 ns       272770 ns         2635
equal_bitset                     0.000 ns        0.000 ns   1000000000
equal_bitset_operator            0.000 ns        0.000 ns   1000000000
equal_itsy_bitsy                   685 ns          684 ns      1120000
equal_itsy_bitsy_operator        0.321 ns        0.328 ns   1000000000
count_by_hand                     5085 ns         5156 ns       100000
count_base                       46455 ns        46038 ns        11200
count_vector_bool                98858 ns        97656 ns         6400
count_bitset                    114628 ns       114746 ns         6400
count_bitset_smart               10441 ns        10498 ns        64000
count_itsy_bitsy                  5020 ns         5082 ns       144516
count_itsy_bitsy_smart            5083 ns         5022 ns       112000
copy_by_hand                       258 ns          255 ns      2635294
copy_base                         3239 ns         3223 ns       213333
copy_vector_bool                195930 ns       196725 ns         3733
copy_bitset                     147936 ns       150663 ns         4978
copy_bitset_operator               255 ns          257 ns      2800000
copy_itsy_bitsy                    261 ns          261 ns      2635294
copy_itsy_bitsy_operator           264 ns          261 ns      2635294
sized_copy_by_hand                 262 ns          261 ns      2635294
sized_copy_base                   3237 ns         3223 ns       213333
sized_copy_vector_bool          212132 ns       209961 ns         3200
sized_copy_bitset               147954 ns       146484 ns         4480
sized_copy_itsy_bitsy              261 ns          261 ns      2635294]]>
			</programlisting>
		</para>
		<para>
			The code for these benchmarks is maintained externally (the GCC codebase is currently not ready to take on a hard dependency on a better benchmarking library and its own benchmarking and performance utilities are sprawling, non-uniform and a bit lacking in places). It was generated with Google Benchmarks on a recent build of GCC. There is still work to be done to improve the
			<code>
				<![CDATA[std::equal(...)]]>
			</code>
			performance to be exactly equivalent to a
			<code>
				<![CDATA[std::memcmp(...)]]>
			</code>
			. This would require using something like
			<code>if constexpr</code>
			to check if the iterators are pointers, and then dispatching to that call directly. It is surprising that
			<code>
				<![CDATA[std::equal(...)]]>
			</code>
			does not do this already, or is perhaps inhibited despite being handed iterators to a vector directly. This is, again, a place where optimizations can be applied to libstdc++ and where everyone would see benefits, rather than just the operators within a
			<code>
				<![CDATA[std::vector]]>
			</code>
			.
		</para>
	</section>
	<section>
		<title>Future Work</title>
		<para>
			There is absolutely more work that can be contributed here. From further optimizations, to better optimized containers, to further improved handling of bit values. There are at least 2 new important containers that should be developed, more optimizations to put into
			<code>
				<![CDATA[bit_sequence]]>
			</code>
			, and more algorithms that can have their speed improved for bit the bit iterators and overall. This work was originall done by ThePhD in the Summer of Code, 2019. Speaking more directly as the person who received the Work-Study stipend to work on this, it is my full expectation that someone else (perhaps you) will pick these up for the next Summer of Code or for a different grant. These structures represent an imperative need in the industry and even for a beginner can give good practice into writing resilient, fast code to be used directly by thousands and perhaps relied upon by millions. If you have the free time and the means, by all means take up the projects listed below. If you do, do not hesitate to
		</para>
		<para>
			<orderedlist>
				<listitem>
					<para>
						Algorithms which could be reasonably optimized include the following:
						<itemizedlist>
							<listitem>
								<para>
									<code>std::rotate</code>
									, to shift an entire
									<code>value_type</code>
									's bits at a time rather than individual bits;
								</para>
							</listitem>
							<listitem>
								<para>
									<code>std::swap_ranges</code>
									, to exchange an entire
									<code>value_type</code>
									's bits at a time with another;
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						There is a lot of places inside of
						<code>
							<![CDATA[bit_sequence<...>]]>
						</code>
						where insertion or erasure could be done even faster than it is now by implementing a better rotate or shift algorithm. There are also optimization opportunities for copying multiple bits at a time using masking rather than default to a one-by-one approach when the incoming iterators are not aligned on the word boundary. Search for
						<code>
							<![CDATA[// TODO]]>
						</code>
						comments in the code residing in
						<code>
							<![CDATA[include/ext/bit_ds]]>
						</code>
						.
					</para>
				</listitem>
				<listitem>
					<para>
						Much of the insert and erase code for
						<code>
							<![CDATA[bit_sequence<...>]]>
						</code>
						does not grant the
						<![CDATA["Strong Exception Guarantee"]]>
						that is known and applied to all standard library containers. Increasing the exception guarantees of the type is an excellent advanced project for anyone interested in diving that deeply into making sure that the code is extremely resilient to insertion failures and allocation failures.
					</para>
				</listitem>
				<listitem>
					<para>
						Another serious optimization potential are 2 classes:
						<code>
							<![CDATA[small_buffer<typename Type, std::size_t MaxInternallyBufferedTypes, typename Allocator>]]>
						</code>
						and
						<code>
							<![CDATA[small_bit_buffer<typename Type, std::size_t MaxInternallyBufferedTypes, typename Allocator>]]>
						</code>
						. The reason there need to be 2 of them is because it is a space loss to store a separate
						<code>size_type</code>
						to track the bit position within a word. This does not mean both cannot share the majority of their code: in fact, an implementation of these two types should share a large degree of their internals, but differ only in the implementation of their
						<code>size()</code>
						,
						<code>insert(...)</code>
						,
						<code>assign(...)</code>
						, and
						<code>erase(...)</code>
						calls. Note that The # of bits required to store the by-the-bit size of a container would be around
						<code>
							<![CDATA[std::floor(std::pow(2, std::log2(binary_digits<Type>))]]>
						</code>
						, which means that most containers concerned with storing and managing a sequence of bits can simply keep the word size in the upper bits and the current occupied count of the words in the lower bits. Implementing these two classes will allow for cases in both high performance and memory-intensive environments where certain nodes can generally fit e.g. sparse hash keys in 128 bits, which requires only a storage of 2
						<code>std::uint64_t</code>
						s in a private buffer. It also solves the problem for more than just these individuals, as the request for the
						<![CDATA["Small Buffer Optimization"]]>
						guarantees has appeared several times over from library and application developers. This makes it prime real estate. If someone chooses to tackle this work for a Summer of Code, it is highly suggested that this is the only thing they work on, as it will likely take all of their time to get it absolutely correct (and perhaps even
						<code>constexpr</code>
						-capable.
					</para>
				</listitem>
			</orderedlist>
		</para>
	</section>
	<section>
		<title>Acknowledgements</title>
		<para>A huge thanks to Dr. Vincent Reverdy for sponsoring and helping with this work. An enormous thank you to Jonathan Wakely, Thomas Rodgers, and Ville Voutilainen for watching over my work during the Summer of Code 2019 through the Free Software Foundation and GNU Compiler Collection project.</para>
		<para>Many thanks to the Blessed Guardian, Morwenn, for watching over my commits and cautioning me of my occasional derps.</para>
		<para>
			Thank you to Corentin Jabot for changing the name "Extents" to "Bounds" to better represent the begin/end type for
			<code>bit_view</code>
			.
		</para>
	</section>
</chapter>